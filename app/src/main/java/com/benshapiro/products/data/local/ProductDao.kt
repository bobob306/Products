package com.benshapiro.products.data.local

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.benshapiro.products.model.Model
import com.benshapiro.products.data.SortOrder
import kotlinx.coroutines.flow.Flow

// This annotation tells Hilt that this is the Data Access Object
// This autogenerates a lot of code for us
@Dao
interface ProductDao {

    /*
    This decides what to do when two items with the same primary key exist
    In this case it replaces the item
    This should not happen as the primary key is autogenerated
    This must be a suspend fun, this would be a long running operation.
    Long running operations should not be done on the main thread as the user can be faced with an ANR (app not responding)
    We use coroutines to do this work off the main thread
    In this case the operation would merely be a few miliseconds, but it is still necessary
     */

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(model: List<Model>)

    /*
    This is a flowchart using a when statement to decide what order the list should be sorted in
    This order governs how it appears in the app, either price highest to lowest, or name alphabetically
    SortOrder is a value that is passed in by the repository in the query section
    (obviously sortOrder is set and passed to the repo but we can't go through that everytime a value is mentioned!)
    -> is an instruction carry out a particular function
    SortOrder has a default value, so the user can still search and use the app without setting a preferred sortOrder
     */
    fun getProducts(query: String, sortOrder: SortOrder): Flow<List<Model>> =
        when (sortOrder) {
            SortOrder.BY_NAME -> getProductsSortedByName(query)
            SortOrder.BY_PRICE -> getProductsSortedByPrice(query)
        }
    /*
    In this case the function is to select * from the table
    * means select all that match the following conditions
    the WHERE name LIKE % searchquery % pattern is saying, look for the search query in the name column, but the query can appear anywhere in the word
    e.g. any product with the letter e in the name will appear if you put e in the search box, even if it is in the middle of the word
    next step is to order by name in ascending order, otherwise known as alphabetical order
    This is returned as a flow, this is continuously emitted list of restaurants.
    This means the list is observable
    Any changes to the database will immediately be updated in the ui (as long as we use livedata)
    All data in the UI will now come from the database, and not from the API (although obviously the API can update the database)
    To collect the flow (seen elsewhere) we will need to use a coroutine.
    However we are merely declaring the flow here, so this is not a suspend function.
     */
    @Query("SELECT * FROM table_product WHERE name LIKE '%' || :searchQuery || '%' ORDER BY name ASC")
    fun getProductsSortedByName(searchQuery: String): Flow<List<Model>>

    /*
    If you understand above you will see this the same except the price is ordered from largest to smallest
     */
    @Query("SELECT * FROM table_product WHERE name LIKE '%' || :searchQuery || '%' ORDER BY price DESC")
    fun getProductsSortedByPrice(searchQuery: String): Flow<List<Model>>

    /*
    This picks all the products (signified by the select * from pattern mentioned above) that satisfy a condition
    The condition is the name which is the product string provided by the function
    In this case there must be a direct match as there are %s surrounding the query
    This is not used in the app because it is less helpful for the user than the above method
     */
    @Query("SELECT * FROM table_product WHERE name LIKE :product")
    fun searchDatabase(product: String): Flow<List<Model>>

    // This simply deletes all values
    // Again this must be a suspend fun, signifying it will utilise coroutines
    @Query("DELETE FROM table_product")
    suspend fun deleteAll()

}